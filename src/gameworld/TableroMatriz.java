/**
 * UNIVERSIDAD DE SAN CARLOS DE GUATEMALA
 * FACULTAD DE INGENIERIA
 * ESCUELA DE CIENCIAS Y SISTEMAS
 * COMPILADORES 1
 * PROYECTO 1
 * Creado el 03 de septiembre 2011, 5:46PM
 */
package gameworld;

import fileops.cache.ImageCache;
import gameworld.actors.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.util.*;
import javax.swing.JOptionPane;

/*
 * Es el tablero matriz a dibujar.
 * @(#)TableroMatriz.java
 * Proyecto1_200819312 application
 * @author David Y. Gonzalez
 */
public class TableroMatriz extends javax.swing.JPanel implements Stage, KeyListener, Runnable {

    public ImageCache imageCache;
    
    /**Fondo del tablero matriz**/
    private Background background;
    /**Heroe del juego actual**/
    private Heroe heroe;
    /**Meta unico actual**/
    private Meta meta;
    /**Arma del heroe, para dibujar**/
    private Arma weapon;
    
    /**Manteniemiento del juego**/
    /**true si el juego ha terminado, false si se esta jugando**/
    private boolean gameEnded;
    
    /**
     * Indicador si el hilo debe continuar
     * Debe ser true antes de darle Thread.start();
     **/
    private boolean threadContinue;
    /**
     * Donde se guardan los actores. Aca se incluyen a los villanos, bonus, arma
     * bomba, bloque
     **/
    private ArrayList<Villano> villanos;
    private ArrayList<Bloque> muros;
    private ArrayList<Arma> armas;
    private ArrayList<Bomba> bombas;
    private ArrayList<Bonus> bonusses;

    public ArrayList<Arma> getArmas() {
        return armas;
    }

    public ArrayList<Bomba> getBombas() {
        return bombas;
    }

    public ArrayList<Bonus> getBonusses() {
        return bonusses;
    }

    public Meta getMeta() {
        return meta;
    }

    public ArrayList<Bloque> getMuros() {
        return muros;
    }

    public ArrayList<Villano> getVillanos() {
        return villanos;
    }
    /**bandera que indica se debe dibujar la cuadricula del tablero**/
    private boolean drawCuadricula;
    
    @Override
    public void run() {
        try {
            while (threadContinue) {
                Thread.sleep(250);
                heroe.move();

                int hi = heroe.pIJ.x, hj = heroe.pIJ.y;
                if (weapon != null) {
                    weapon.move();
                }
                for (Arma a : armas) {
                    if (a.pIJ.x == hi && a.pIJ.y == hj) {
                        heroe.hitArma(a);
                    }
                }
                for (Bonus b : bonusses) {
                    if (b.pIJ.x == hi && b.pIJ.y == hj) {
                        heroe.hitBonus(b);
                    }
                }
                for (Bomba b : bombas) {
                    if (b.pIJ.x == hi && b.pIJ.y == hj) {
                        heroe.hitBomba(b);
                    }
                }
                for (Villano v : villanos) {
                    v.move();
                    if (v.pIJ.x == heroe.pIJ.x && v.pIJ.y == heroe.pIJ.y) {
                        //ver si golpeo a heroe o arma
                        v.hitHeroe(heroe);
                        heroe.hitVillano(v);
                    }
                    if (weapon != null) {
                        //verificar que no se elimino con la colision del heroe
                        if (!v.isMarkedForRemoval() && v.pIJ.x == weapon.pIJ.x && v.pIJ.y == weapon.pIJ.y) {
                            weapon.hitVillano(v, heroe.getX_vida());
                        }
                    }

                }
                if (meta.pIJ.x == heroe.pIJ.x && meta.pIJ.y == heroe.pIJ.y) {
                    //llego a la meta
                    heroe.hitMeta(meta);
                }
                paint();
            }
        } catch (Exception e) {
        }
        if (gameEnded) {
            String msn, title;
            if (heroe.getX_vida() <= 0) {
                //perdio
                msn = "Haz perdido la partida";
                title = "Mal tiempo";
            } else {
                //llego a la meta
                msn = "Haz ganado la partida!";
                title = "En buena hora!";
            }
            JOptionPane.showMessageDialog(this, msn, title, JOptionPane.INFORMATION_MESSAGE);
        }
    }

    /** Creates new form TableroMatriz */
    public TableroMatriz() {
        initComponents();
        this.botarStage();
        
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setMaximumSize(new java.awt.Dimension(600, 600));
        setMinimumSize(new java.awt.Dimension(600, 600));
        setPreferredSize(new java.awt.Dimension(640, 640));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public ImageCache getImageCache() {
        return imageCache;
    }


    @Override
    public Heroe getHeroe() {
        return heroe;
    }

    @Override
    public void gameOver() {
        threadContinue = false;//para finalizar el hilo
        gameEnded = true;
    }

    @Override
    public void keyTyped(KeyEvent e) {
        //System.out.println("TableroMatriz keyTyped");
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (threadContinue)heroe.keyPressed(e);
    }

    @Override
    public void keyReleased(KeyEvent e) {
        if (threadContinue)heroe.keyReleased(e);
    }
    

    @Override
    protected void paintComponent(Graphics g) {
        //super.paintComponent(g);
        BufferedImage BIFondo = new BufferedImage(Stage.WIDTH, Stage.HEIGHT, BufferedImage.TRANSLUCENT);
        Graphics2D g2dFondo = BIFondo.createGraphics();
        g2dFondo.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);//antialiasing

        background.paint(g2dFondo);
        if (weapon != null){ 
            if (weapon.markedForRemoval){
                weapon = null;
            } else weapon.paint(g2dFondo);
        }
        for (int i = muros.size() - 1; i >= 0; i--) {
            Bloque b = muros.get(i);
            if (b.markedForRemoval) {
                muros.remove(i); 
            } else b.paint(g2dFondo);
        }
        for (int i = villanos.size() - 1; i >= 0; i--) {
            Villano v = villanos.get(i);
            if (v.markedForRemoval) {
                villanos.remove(i);
                System.out.printf("Se ha eliminado Villano (%d,%d)\n", v.pIJ.x, v.pIJ.y);
            } else v.paint(g2dFondo);
        }
            
        for (int i = armas.size() - 1; i >= 0; i--){
            Arma a = armas.get(i);
            if (a.markedForRemoval){
                armas.remove(i);
            } else a.paint(g2dFondo);
        }
            
        for (int i = bombas.size() - 1; i >= 0; i--){
            Bomba b = bombas.get(i);
            if (b.markedForRemoval) {
                bombas.remove(b);
            } else b.paint(g2dFondo);
        } 
            
        for (int i = bonusses.size() - 1; i >=0; i--) {
            Bonus b = bonusses.get(i);
            if (b.markedForRemoval) {
                bonusses.remove(i); 
            } else b.paint(g2dFondo);
        }
            
        meta.paint(g2dFondo);
        heroe.paint(g2dFondo);

        if (drawCuadricula){
            for (int i = 1; i < 20; i++){
                g2dFondo.setColor(Color.red);
                g2dFondo.drawLine(0, i*Box.LENGTH, Box.LENGTH*20, i*Box.LENGTH);
                g2dFondo.drawLine(i*Box.LENGTH, 0, i*Box.LENGTH, Box.LENGTH*20);
            }
        }
        
        Graphics2D g2 = (Graphics2D) g;
        if (BIFondo!=null)
            g2.drawImage(BIFondo, 0, 0, this);//Dibuja el producto final
        
    }

    

    @Override
    public void setBackground(Background background) {
        this.background = background;
    }

    @Override
    public Background getBground() {
        return background;
    }
    
    /**
     * Dibuja la cradicula
     * @param drawCuadricula true para dibujar, falso para no
     **/
    public void setDrawCuadricula(boolean drawCuadricula) {
        this.drawCuadricula = drawCuadricula;
        paint();
    }
    
    /**
     * Inicializa el hilo para jugar.
     * Sera llamado cuando no se ha terminado el juego y cada vez que el juego este pausado.
     * Se llama desde TableroGame_GUI.java
     **/
    public void game() {
        threadContinue = true;
        new Thread(this).start();
    }
    @Override 
    public boolean isBloque(int i, int j){
        
        if (i < 0 || i > 19 || j < 0 || j > 19) {
            return true;
        }
        //Si esta adentro los limites del tablero, analiza los muros
        for (Bloque b: muros){
            if (b.pIJ.x == i && b.pIJ.y == j)
                return true;
        }
        return false;
    
    }
    
    @Override
    public void paint(){
        paintComponent(getGraphics());
    }
    
    @Override
    public void addVillano(Villano v) {
        villanos.add(v);
    }

    @Override
    public void addMuro(Bloque b) {
        muros.add(b);
    }

    @Override
    public void addArma(Arma a) {
        armas.add(a);
    }

    @Override
    public void addBomba(Bomba b) {
        bombas.add(b);
    }

    @Override
    public void addBonus(Bonus b) {
        bonusses.add(b);
    }
    @Override
    public void setHeroe(Heroe heroe) {
        this.heroe = heroe;
    }
    @Override
    public void setMeta(Meta m) {
        meta = m;
    }

    @Override
    public void setWeapon(Arma weapon) {
        this.weapon = weapon;
    }
    @Override
    public boolean hasWeapon(){
        return (weapon != null);
    }
    /**
     * Utilizado por el JFrame que contiene este JPanel
     * @return true si el juego no continua
     **/
    @Override
    public boolean isGameEnded(){
        return gameEnded;
    }
    
    /**
     * Mata al hilo principal. Pero el juego no acaba
     * Sera llamada desde TableroGame_GUI.java
     **/
    public void gamePause(){
        threadContinue = false;
    }
    /**
     * Indica si el juego esta activo (pausado o no)
     * Es llamado desde TableroGame_GUI.java.
     * Nunca sera llamado si el juego ha terminado.
     * @return true si el hilo esta activado. false si esta en pausa o no ha comenzado jugar
     **/
    public boolean gamePlaying(){
        return threadContinue;
    }
    /**
     * Utilizado por el JFrame PRINCIPAL 
     * Alista el escenario para un nuevo escaneo.
     * Utilizado por cada nuevo analisis sintactico
     * y en el constructor
     **/
    public final void botarStage(){
        gameEnded = false;
        threadContinue = false;
        imageCache = new ImageCache();
        villanos = new ArrayList<>(15);
        muros = new ArrayList<>(35);
        armas = new ArrayList<>(10);
        bombas = new ArrayList<>(10);
        bonusses = new ArrayList<>(5);
        
        background = new Background(this);//Background default
        heroe = new Heroe(this);
        meta = new Meta(this);
        weapon = null;
    }
    
}
